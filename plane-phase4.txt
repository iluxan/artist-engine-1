# EVENT DISCOVERY AGENT - PHASE 4 PLAN

## Overview
Phase 4 adds the core functionality: automatic event discovery, parsing, and monitoring. This transforms the app from a source tracker into a true event discovery agent that actively finds and notifies users about events.

## Goals
1. Implement the actual source discovery
2. Check usual event types
1. Parse events from discovered sources
2. Store and manage event data
3. Implement scheduled source checking
4. Add notifications for new events
5. Build event viewing and filtering interface
6. Detect duplicate/similar events across sources

## Event Parsing Strategy

### Source Type Parsers

4. **Twitter/X Parser**
   - Monitor tweets for event keywords
   - Pattern matching: dates, locations, "show", "concert", "appearing"
   - Extract potential events with lower confidence
   - Confidence: Medium-Low (requires validation)

5. **Instagram Parser**
   - Parse captions for event announcements
   - Look for date/location patterns
   - Link to external event pages
   - Confidence: Medium-Low

6. **Website/Blog Parser**
   - Generic web scraping
   - Look for calendar/events pages
   - Pattern matching for dates and locations
   - Structured data extraction (schema.org events)
   - Confidence: Medium (varies by site structure)

7. **Facebook Events Parser**
   - Use Facebook Graph API
   - Query public events from pages
   - Extract full event details
   - Confidence: High (structured data)

### Parsing Infrastructure

Module: eventParsers.js
- Base parser class with common functionality
- Individual parser implementations for each source type
- Unified event object format
- Error handling and logging

Module: eventExtractor.js
- Date/time extraction and normalization
- Location/venue extraction
- URL detection and validation
- Deduplication logic

Module: scheduler.js
- Cron-based scheduled checks
- Queue management for parsing jobs
- Rate limiting per source type
- Retry logic for failed parses

## Database Enhancements

### New Tables

TABLE: events (expand from phase 2 stub)
- id (INTEGER PRIMARY KEY AUTOINCREMENT)
- person_id (INTEGER FOREIGN KEY -> people.id)
- source_id (INTEGER FOREIGN KEY -> sources.id)
- title (TEXT NOT NULL)
- description (TEXT)
- event_date (DATETIME)
- event_end_date (DATETIME)
- location (TEXT)
- venue (TEXT)
- city (TEXT)
- country (TEXT)
- url (TEXT)
- ticket_url (TEXT)
- confidence (TEXT) - high, medium, low
- status (TEXT) - upcoming, past, cancelled, postponed
- discovered_at (DATETIME DEFAULT CURRENT_TIMESTAMP)
- last_verified (DATETIME)
- external_id (TEXT) - ID from source platform
- raw_data (TEXT) - JSON of original parsed data
- UNIQUE(source_id, external_id)

TABLE: event_notifications
- id (INTEGER PRIMARY KEY AUTOINCREMENT)
- event_id (INTEGER FOREIGN KEY -> events.id)
- user_id (INTEGER) - for future multi-user support
- notification_type (TEXT) - email, push, sms
- sent_at (DATETIME)
- status (TEXT) - pending, sent, failed

TABLE: duplicate_events
- id (INTEGER PRIMARY KEY AUTOINCREMENT)
- event_id_1 (INTEGER FOREIGN KEY -> events.id)
- event_id_2 (INTEGER FOREIGN KEY -> events.id)
- similarity_score (REAL) - 0.0 to 1.0
- is_confirmed_duplicate (BOOLEAN)
- created_at (DATETIME)

TABLE: parse_jobs
- id (INTEGER PRIMARY KEY AUTOINCREMENT)
- source_id (INTEGER FOREIGN KEY -> sources.id)
- status (TEXT) - pending, running, completed, failed
- started_at (DATETIME)
- completed_at (DATETIME)
- events_found (INTEGER)
- error_message (TEXT)

### Schema Updates

ALTER TABLE sources
- Add: parse_frequency (TEXT) - daily, weekly, hourly
- Add: last_parsed (DATETIME)
- Add: next_parse (DATETIME)
- Add: parse_enabled (BOOLEAN DEFAULT true)
- Add: parser_type (TEXT) - which parser to use

ALTER TABLE people
- Add: notification_enabled (BOOLEAN DEFAULT true)
- Add: notification_preferences (TEXT) - JSON config

## Backend Changes

### New Dependencies
- node-cron (scheduled tasks)
- date-fns or moment (date parsing and manipulation)
- cheerio (already have - web scraping)
- node-fetch or axios (HTTP requests)
- string-similarity (duplicate detection)
- Optional: API client libraries (eventbrite-sdk, etc.)

### New API Endpoints

#### Events
1. GET /api/events
   - Query params: person_id, date_from, date_to, status, limit, offset
   - Returns paginated list of events
   - Response: { events: [...], total, page, pages }

2. GET /api/events/:id
   - Returns detailed event information
   - Response: { id, title, date, person, source, ... }

3. GET /api/people/:id/events
   - Returns all events for a specific person
   - Query params: upcoming_only, limit, offset
   - Response: { events: [...], total }

4. POST /api/events
   - Manually add an event
   - Body: { person_id, source_id?, title, date, location, url, ... }
   - Response: { id, ...event_data }

5. PUT /api/events/:id
   - Update event details
   - Body: { title?, date?, status?, ... }
   - Response: { id, ...updated_data }

6. DELETE /api/events/:id
   - Delete an event
   - Response: { success: true }

7. POST /api/events/:id/mark-duplicate
   - Mark two events as duplicates
   - Body: { duplicate_event_id }
   - Response: { success: true }

#### Parsing & Discovery
8. POST /api/sources/:id/parse
   - Manually trigger parsing for a source
   - Response: { job_id, status, events_found }

9. POST /api/people/:id/parse-all
   - Parse all sources for a person
   - Response: { jobs: [...], total_sources }

10. GET /api/parse-jobs/:id
    - Check status of a parse job
    - Response: { id, status, events_found, error }

11. POST /api/parse/schedule
    - Configure parsing schedule
    - Body: { source_id, frequency, enabled }
    - Response: { success, next_parse }

#### Settings & Notifications
12. GET /api/settings/notifications
    - Get notification preferences
    - Response: { email, push, frequency, ... }

13. PUT /api/settings/notifications
    - Update notification preferences
    - Body: { email?, enabled?, ... }
    - Response: { updated_settings }

14. GET /api/notifications
    - Get notification history
    - Response: { notifications: [...] }

### Core Modules

#### eventParsers.js
```javascript
class BaseParser {
  async parse(source) { /* abstract */ }
  extractDate(text) { /* helper */ }
  extractLocation(text) { /* helper */ }
  normalizeEvent(rawData) { /* helper */ }
}

class EventbriteParser extends BaseParser { }
class SongkickParser extends BaseParser { }
class TwitterParser extends BaseParser { }
// ... etc
```

#### parsingService.js
- Manages parsing jobs
- Selects appropriate parser for source
- Handles errors and retries
- Saves discovered events to database
- Triggers duplicate detection

#### duplicateDetection.js
- Compare events by title, date, location
- Calculate similarity scores
- Auto-merge confirmed duplicates
- Flag potential duplicates for review

#### notificationService.js
- Check for new events since last notification
- Format notification messages
- Send via configured channels (email/push)
- Track notification history

#### scheduler.js
- Initialize cron jobs
- Parse sources based on schedule
- Handle job queuing and concurrency
- Log job results

## Frontend Changes

### New Pages/Views

1. **Events Dashboard (New Homepage)**
   - Calendar view of upcoming events
   - List view with filters
   - Group by person or date
   - Quick stats (X events in next 30 days)
   - Filter: date range, person, location, status

2. **Event Detail View**
   - Full event information
   - Link to original source
   - Ticket/registration links
   - Edit/delete options
   - Mark as attending/interested
   - Report duplicate

3. **Calendar View**
   - Monthly calendar with event markers
   - Click date to see events
   - Color-coded by person
   - Export to iCal/Google Calendar

4. **Parsing Status View**
   - Show last parse time for each source
   - Parsing progress/status
   - Manual "Refresh" button per source
   - Error logs and retry options

5. **Settings/Preferences**
   - Notification preferences
   - Parsing frequency per source
   - Enable/disable sources
   - Email/push configuration

6. **People View (Enhanced from Phase 2)**
   - Add: Event count
   - Add: Next upcoming event date
   - Add: Last parsed timestamp
   - Add: "Parse Now" action button

### UI Components

Component: EventCard
- Display event with date, location, person
- Status badge (upcoming, past, etc.)
- Ticket/info links

Component: Calendar
- Month/week views
- Event markers
- Click to view details

Component: ParseProgress
- Real-time parsing status
- Progress bar for multi-source parsing
- Event count updates

Component: NotificationSettings
- Toggle switches for channels
- Frequency selector
- Test notification button

### Enhanced Navigation
- Dashboard (Events)
- Calendar
- People (from Phase 2)
- Discover (from Phase 1)
- Settings

## Implementation Steps

### Step 1: Database & Models (3-4 hours)
1. Create events table schema
2. Create notification tables
3. Update sources table with parse config
4. Write event query functions
5. Add indexes for performance

### Step 2: Event Parsers (8-10 hours)
1. Implement base parser class
2. Create Eventbrite parser
3. Create Songkick parser
4. Create generic website parser
5. Create Twitter parser (optional)
6. Test each parser individually

### Step 3: Parsing Service (4-5 hours)
1. Build parsingService.js
2. Implement job queue
3. Add error handling and retries
4. Test parsing workflow
5. Add logging

### Step 4: Scheduler (2-3 hours)
1. Implement scheduler.js with node-cron
2. Configure default schedules
3. Add manual trigger support
4. Test scheduled execution

### Step 5: Duplicate Detection (3-4 hours)
1. Implement similarity algorithm
2. Compare events on save
3. Auto-flag duplicates
4. Add manual merge functionality

### Step 6: Backend API (4-5 hours)
1. Implement events endpoints
2. Add parsing trigger endpoints
3. Create notification endpoints
4. Test all new endpoints

### Step 7: Frontend - Events Dashboard (5-6 hours)
1. Create events list view
2. Add filtering and sorting
3. Implement event cards
4. Add pagination
5. Connect to backend API

### Step 8: Frontend - Calendar View (4-5 hours)
1. Integrate calendar library or build custom
2. Display events on calendar
3. Add month/week navigation
4. Click handlers for event details

### Step 9: Frontend - Settings & Notifications (3-4 hours)
1. Create settings page
2. Build notification preferences UI
3. Add source parsing configuration
4. Connect to backend

### Step 10: Notifications Implementation (5-6 hours)
1. Set up email service (SendGrid/Mailgun)
2. Implement notificationService.js
3. Create email templates
4. Add push notifications (optional)
5. Test notification delivery

### Step 11: Integration & Testing (4-5 hours)
1. End-to-end testing of parsing flow
2. Test notification delivery
3. Test duplicate detection
4. Load testing with multiple sources
5. Fix bugs and edge cases

### Step 12: Polish & Documentation (2-3 hours)
1. Add loading states and animations
2. Improve error messages
3. Update README with Phase 3 features
4. Add user guide for new features

## Testing Plan

### Unit Tests
- Each parser implementation
- Date/location extraction functions
- Duplicate detection algorithm
- Event normalization

### Integration Tests
- Full parsing workflow
- Event creation and storage
- Notification sending
- Scheduler execution
- API endpoints

### Manual Testing Scenarios
1. Add person → discover sources → parse events
2. Schedule automatic parsing → verify events appear
3. Manually add event → check for duplicates
4. Configure notifications → verify delivery
5. Test with real sources (artist, performer, etc.)
6. Calendar navigation and filtering
7. Mark events as duplicates
8. Edit/delete events

## Success Criteria
- [ ] System can parse events from at least 3 source types
- [ ] Events are stored with accurate date/location data
- [ ] Scheduled parsing runs automatically
- [ ] Duplicate events are detected with >80% accuracy
- [ ] Users receive notifications for new events
- [ ] Calendar view displays events correctly
- [ ] Parsing errors are logged and retryable
- [ ] UI is responsive and intuitive
- [ ] Data persistence works across restarts

## Performance Considerations

### Optimization Strategies
1. **Parsing**
   - Rate limiting per source type
   - Parallel parsing with worker threads
   - Cache parsed data for short duration
   - Incremental parsing (only new content)

2. **Database**
   - Index on person_id, event_date, status
   - Pagination for large event lists
   - Archiving old events

3. **API**
   - Response caching for event lists
   - Lazy loading for event details
   - Compression for large responses

4. **Frontend**
   - Virtual scrolling for long lists
   - Debounced search/filter
   - Optimistic UI updates

## Security & Privacy

### Considerations
- API keys stored securely (environment variables)
- Rate limiting to prevent abuse
- Input validation for all endpoints
- Sanitize scraped content
- CORS configuration
- Email address validation
- Secure credential storage for notifications

## API Keys & External Services

### Required/Optional Services
1. **Required for Full Functionality**
   - Eventbrite API (free tier available)
   - Songkick API (free for non-commercial)

2. **Optional but Recommended**
   - Twitter API (requires approval)
   - Facebook Graph API
   - SendGrid/Mailgun (email notifications)

3. **Self-Hosted Alternatives**
   - Generic web scraping (no API needed)
   - Local notification system (no external service)

## Future Enhancements (Phase 4+)

### Advanced Features
- Natural language event extraction using LLMs
- Image recognition for event posters
- Automatic ticket purchasing
- Event recommendations based on preferences
- Social features (share events with friends)
- Integration with calendar apps (Google Calendar, iCal)
- Mobile app with push notifications
- RSS feed generation for events
- Event history and analytics
- Multi-language support
- Geolocation-based filtering
- Price tracking for tickets

### AI/ML Enhancements
- Smart duplicate detection with ML
- Event relevance scoring
- Predict which events user will attend
- Anomaly detection (cancelled events)
- Sentiment analysis of event buzz

## Estimated Timeline
- Database & Models: 3-4 hours
- Event Parsers: 8-10 hours
- Parsing Service: 4-5 hours
- Scheduler: 2-3 hours
- Duplicate Detection: 3-4 hours
- Backend API: 4-5 hours
- Frontend Events Dashboard: 5-6 hours
- Frontend Calendar: 4-5 hours
- Frontend Settings: 3-4 hours
- Notifications: 5-6 hours
- Integration & Testing: 4-5 hours
- Polish & Documentation: 2-3 hours

**Total: 47-60 hours**

## Rollout Strategy

### Phased Rollout
1. **Phase 3a (MVP)**: Basic parsing + event storage (20-25 hours)
   - Eventbrite parser only
   - Manual parsing triggers
   - Basic event list view
   - No notifications

2. **Phase 3b (Automation)**: Scheduler + more parsers (15-20 hours)
   - Add Songkick parser
   - Automated scheduled parsing
   - Calendar view

3. **Phase 3c (Complete)**: Notifications + polish (12-15 hours)
   - Email notifications
   - Duplicate detection
   - Full UI polish

## Notes
- Start with high-confidence parsers (Eventbrite, Songkick)
- Generic web scraping is hardest and least reliable
- Consider using LLM for event extraction from unstructured text
- Be mindful of API rate limits
- Store raw parsed data for debugging
- Build admin view to monitor parsing health
- Consider cost of external services (APIs, email)